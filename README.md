# MapLab

**MapLab** — это интерактивное мобильное приложение для создания маркеров на карте с возможностью добавления изображений. Приложение разработано с использованием Expo, React Native и TypeScript.

## Инструкции по установке

### Предварительные требования

- **Node.js** (версия 18.0.0 или выше) - [Скачать](https://nodejs.org/)
- **npm** или **yarn** (поставляется с Node.js)
- **Expo CLI** - устанавливается глобально: `npm install -g @expo/cli`
- **iOS Simulator** (для macOS) или **Android Studio** с эмулятором
- **Expo Go** на мобильном устройстве (опционально)

### Пошаговая установка

1. **Клонирование репозитория**
   ```bash
   git clone <repository-url>
   cd MapLab
   ```

2. **Установка зависимостей**
   ```bash
   # С использованием npm
   npm install
   
   # С использованием yarn
   yarn install
   ```

3. **Проверка зависимостей (опционально)**
   ```bash
   npx expo doctor
   ```

4. **Запуск приложения**
   ```bash
   # Запуск в режиме разработки
   npm start
   # или
   yarn start
   
   # Запуск с очисткой кеша (при проблемах)
   npx expo start -c
   ```

5. **Открытие приложения**
    - **iOS Simulator**: нажмите `i` в терминале
    - **Android Emulator**: нажмите `a` в терминале
    - **Веб-браузер**: нажмите `w` в терминале
    - **Физическое устройство**: отсканируйте QR-код в приложении Expo Go

## Использование

1. **Создание маркера**: Сделайте длинное нажатие на любом месте карты
2. **Просмотр маркера**: Нажмите на существующий маркер для перехода к деталям
3. **Добавление изображений**: В экране деталей маркера нажмите "Добавить фото"
4. **Удаление изображений**: Нажмите на крестик в углу изображения или сделайте длинное нажатие
5. **Удаление маркера**: В экране деталей маркера нажмите красную кнопку "Удалить маркер" (с подтверждением)

## Система отслеживания и уведомлений

Приложение автоматически отслеживает ваше местоположение и уведомляет о приближении к созданным меткам.

### Как это работает

- **Автоматический запуск**: Отслеживание начинается при открытии карты и останавливается при выходе
- **Высокая точность**: Использует GPS с обновлением каждые 5 секунд или при перемещении на 5 метров
- **Зона уведомлений**: Радиус 100 метров вокруг каждой метки (отображается голубым кругом на карте)
- **Умные уведомления**: 
  - Уведомление приходит только при **первом входе** в зону метки
  - Пока вы находитесь в зоне - повторные уведомления не приходят (предотвращение спама)
  - При выходе из зоны и повторном входе - уведомление придет снова

### Предотвращение дублирования

Система использует **трехуровневую защиту** от дублирования уведомлений:

1. **Блокировка параллельной обработки**: `Set` не позволяет обрабатывать одну метку одновременно
2. **Отслеживание состояний**: `Map` хранит состояние каждой метки (в зоне/вне зоны)
3. **Автоматический сброс**: При выходе из зоны состояние сбрасывается для возможности повторного уведомления

### Архитектура

```
Location Service → Proximity Tracking → Notification Manager
     ↓                    ↓                      ↓
  GPS данные    Проверка расстояний    Умные уведомления
```

**Ключевые файлы:**
- `services/location-service.ts` - работа с GPS
- `services/notification-manager.ts` - логика уведомлений
- `hooks/use-location.ts` - React-интеграция
- `components/Map.tsx` - использование в UI

## Документация схемы базы данных

### Обзор базы данных

Приложение использует **SQLite** в качестве локальной базы данных через **expo-sqlite**. База данных автоматически инициализируется при первом запуске приложения.

### Схема таблиц

#### Таблица `markers`
Хранит основную информацию о маркерах на карте.

```sql
CREATE TABLE markers (
  id TEXT PRIMARY KEY,              -- Уникальный идентификатор маркера
  latitude REAL NOT NULL,           -- Широта (координата Y)
  longitude REAL NOT NULL,          -- Долгота (координата X)
  title TEXT NOT NULL DEFAULT '',   -- Заголовок маркера
  description TEXT NOT NULL DEFAULT '', -- Описание маркера
  created_at TEXT NOT NULL,         -- Дата создания (ISO строка)
  updated_at TEXT NOT NULL          -- Дата последнего обновления (ISO строка)
);
```

#### Таблица `images`
Хранит информацию об изображениях, привязанных к маркерам.

```sql
CREATE TABLE images (
  id TEXT PRIMARY KEY,              -- Уникальный идентификатор изображения
  marker_id TEXT NOT NULL,          -- ID маркера (внешний ключ)
  uri TEXT NOT NULL,                -- Путь/URI к изображению
  name TEXT NOT NULL,               -- Имя файла изображения
  date_added TEXT NOT NULL,         -- Дата добавления (ISO строка)
  size INTEGER,                     -- Размер файла в байтах (опционально)
  type TEXT,                        -- MIME тип изображения (опционально)
  FOREIGN KEY (marker_id) REFERENCES markers (id) ON DELETE CASCADE
);
```

### Особенности реализации

- **Каскадное удаление**: При удалении маркера автоматически удаляются все связанные изображения
- **Транзакции**: Все операции с несколькими таблицами выполняются в транзакциях
- **Внешние ключи**: Включена поддержка foreign keys для обеспечения целостности данных

## Описание подхода к обработке ошибок

### Централизованная система обработки ошибок

Приложение использует многоуровневую систему обработки ошибок для обеспечения надежности и хорошего пользовательского опыта.

#### 1. Типизированные ошибки

```typescript
export type ErrorType =
  | "image"      // Ошибки работы с изображениями
  | "navigation" // Ошибки навигации
  | "map"        // Ошибки карты
  | "general"    // Общие ошибки
  | "permission" // Ошибки разрешений
  | "database"   // Ошибки базы данных
  | "transaction" // Ошибки транзакций
  | "connection"; // Ошибки соединения

export interface ErrorState {
  readonly message: string;    // Сообщение для пользователя
  readonly type: ErrorType;    // Категория ошибки
  readonly timestamp?: Date;   // Время возникновения
  readonly details?: string;   // Дополнительные детали
}
```

#### 2. Компонент ErrorHandler

Централизованный компонент для отображения ошибок:

```typescript
// components/ErrorHandler.tsx
export default function ErrorHandler({ error, onDismiss }: ErrorHandlerProps) {
  if (!error) return null;
  
  return (
    <View style={styles.container}>
      <Text style={styles.message}>{error.message}</Text>
      <TouchableOpacity style={styles.button} onPress={onDismiss}>
        <Text style={styles.buttonText}>Закрыть</Text>
      </TouchableOpacity>
    </View>
  );
}
```

#### 3. Утилиты для обработки ошибок

```typescript
// utils/helpers.ts
export const handleError = (
  error: unknown,
  fallbackMessage: string
): ErrorState => {
  const message = error instanceof Error ? error.message : fallbackMessage;
  console.error("Application Error:", error);
  
  return {
    type: "general",
    message,
    timestamp: new Date(),
  };
};
```

#### 4. Стратегии восстановления

- **Повторные попытки**: Автоматические повторы для операций с базой данных
- **Откат состояния**: При ошибке состояние возвращается к предыдущему
- **Graceful degradation**: Приложение продолжает работать даже при частичных ошибках
- **Пользовательские уведомления**: Понятные сообщения об ошибках на русском языке

## Выбор ORM и детали реализации

### Почему не используется ORM?

В данном проекте принято решение **НЕ использовать ORM** по следующим причинам:

#### Обоснование решения

1. **Простота схемы**: Приложение использует всего 2 таблицы с простыми связями
2. **Производительность**: Прямые SQL запросы быстрее ORM запросов
3. **Контроль**: Полный контроль над SQL запросами и оптимизациями
4. **Размер приложения**: Отсутствие дополнительных зависимостей

#### Преимущества текущего подхода

- **Типобезопасность**: TypeScript интерфейсы для всех моделей данных
- **Производительность**: Оптимизированные запросы без ORM overhead
- **Отладка**: Прозрачность всех выполняемых запросов

### Принятые архитектурные решения

#### 1. State Management - Zustand

**Почему выбрано:**
- Легковесная альтернатива Redux (2KB vs 50KB+)
- Отличная интеграция с TypeScript
- Middleware для подписок и персистентности

**Реализация:**
- Разделение на логические store (markers, images)
- Использование subscribeWithSelector middleware
- Строгая типизация всех действий и состояний

## Известные ограничения

### Технические ограничения

1. **Производительность карты**
    - При большом количестве маркеров (>100) возможны задержки отрисовки

2. **Работа с изображениями**
    - Максимальный размер файла ограничен 5MB
    - Поддерживаются только JPEG и PNG форматы
    - Нет автоматического сжатия больших изображений

3. **Offline режим**
    - Требуется интернет-соединение для отображения тайлов карты
    - Маркеры и изображения работают offline (SQLite)

4. **Веб-платформа**
    - Ограниченный функционал геолокации в браузере
    - Не все нативные API доступны в веб-версии

5. **База данных**
    - Нет облачной синхронизации между устройствами
    - Локальное хранилище ограничено памятью устройства

6. **Уведомления**
    - Работают только локальные уведомления (push не реализованы)
    - На Android требуется явное предоставление разрешений
    - На Web уведомления не поддерживаются
